function prep_for_extraction_scripts, this_tsa_imagelist_csv, this_tsa_extracted_patchinfo_csv, $
    object_ids_to_use, outputdir, projectid
   
 ;create the three .csv files needed for extraction, and then return the 
 ;    command we'd need to implement it. 
 ;    Files:  
 ;        sample_file:  plot location file
 ;        image_list:  image list file
 ;        

 ;        
; From Yang:
; This script is not as generic as it should be. It is build to work with local need. 
;
;usage: python extract_chip.py tsa sample_file image_list chip_dir
;
;        where tsa: scene name as int, e.g. 44031
;              sample_file: plot location
;              image_list: list of images to use
;              chip_dir: chip output directory
;
;Please see the template file for plot location and image list format.
;
;Image chips are created in chip_dir/ts_pprr, e.g. chip_dir/ts_4431. Within the chip directory, chips are organized by plot, each plot has its own directory named plot_ID, e.g. plot_1. Within the plot directory, each image chip is saved as png file named tsa_PPRR_plot_ID_YEAR-DAY.png, e.g. tsa_4431_plot_1031_1984-187.png
;
;Spectral information are stored as ts_PPRR_spectral.csv in chip output directory, e.g. ts_4431_spectral.csv. This file will be loaded into region_spectral table in timesync database.
 
 ;
 ;inputs:  this_tsa_imagelist_csv:  generated by summarize_by_patch 
 ;          this_tsa_extracted_patchfino_csv:  same
 ;          object_ids_to_use -- selected some othe rway
 ;        outputdir:  directory to place the sample file and the image list
 ;            a subdirectory for the chips will be created as well
 ;projectid:  the code for the project in the LTlabel interface.  needed to link everything together.
 
    
    if file_exists(strcompress(this_tsa_imagelist_csv,/rem)) eq 0 then message, 'could not find the '+this_tsa_imagelist_csv
    if file_exists(strcompress(this_tsa_extracted_patchinfo_csv,/rem)) eq 0 then message, 'could not find the '+this_tsa_extracted_patchinfo_csv
   
   
  ;get the tsa
     
    ok =read_generic_csv(this_tsa_extracted_patchinfo_csv)
    patchinfo=ok.vals
    tsa10000s = patchinfo[0].tsa
    path = tsa10000s / 1000 
    row = tsa10000s-(path*1000)
    tsa = (path*100)+row


  ;subset
    
    n_patches_to_extract = n_elements(object_ids_to_use)
    indices = lonarr(n_patches_to_extract)
    
    h=histogram(patchinfo.object_id, min=1, rev=r)
    
    for i = 0, n_patches_to_extract-1 do $
        if r[r[object_ids_to_use[i]-1]] ne r[r[object_ids_to_use[i]]] then $
              indices[i]=r[r[object_ids_to_use[i]-1]] else indices[i]=-1


        goods = where(indices ne -1, n_goods)

    if n_goods ne n_patches_to_extract then print, 'WARNING: could not find all patches'

    subset_patches = patchinfo[indices[goods]]
    
    ;this is going to go into "plots" table in the database.  
;        ;
;    +----------------+---------+------+-----+---------+-------+
;    | Field          | Type    | Null | Key | Default | Extra |
;    +----------------+---------+------+-----+---------+-------+
;    | project_id     | int(11) | YES  |     | NULL    |       |
;    | tsa            | int(11) | YES  |     | NULL    |       |
;    | plotid         | int(11) | YES  |     | NULL    |       |
;    | x              | double  | YES  |     | NULL    |       |
;    | y              | double  | YES  |     | NULL    |       |
;    | lat            | double  | YES  |     | NULL    |       |
;    | lng            | double  | YES  |     | NULL    |       |
;    | dist_year      | int(11) | YES  |     | NULL    |       |
;    | sequence_order | int(11) | YES  |     | 0       |       |
;    +----------------+---------+------+-----+---------+-------+
;        
  
    base = {project_id:projectid, tsa:tsa, plotid:0l, x:0., y:0., lat:0., long:0., dist_year:0, sequence_order:0}
    
    samples = replicate(base, n_patches_to_extract)
    for i = 0, n_patches_to_extract-1 do begin 
        ; samples[i].tsa = patchinfo[indices[i]].tsa
         samples[i].plotid = patchinfo[indices[i]].plot_id
         samples[i].x = patchinfo[indices[i]].x
         samples[i].y = patchinfo[indices[i]].y
         samples[i].lat = patchinfo[indices[i]].laty          ;#
         samples[i].long = patchinfo[indices[i]].latx         ;#backwards naming from the extraction routine
         samples[i].dist_year = patchinfo[indices[i]].yodmode
        ; #both projectID and sequence order stay the same -- not sure what sequence order is. 
    end
    
   ;GET THE IMAGE LIST STUFF
   
     ok =read_generic_csv(this_tsa_imagelist_csv)
    imageinfo=ok.vals
    n_images = n_elements(imageinfo)
    
    ;for the image list file, I just need to add on the projectID
    ;here's what is in the database:
;    +------------+--------------+------+-----+---------+-------+
;| Field      | Type         | Null | Key | Default | Extra |
;+------------+--------------+------+-----+---------+-------+
;| project_id | int(11)      | YES  |     | NULL    |       |
;| tsa        | int(11)      | YES  |     | NULL    |       |
;| imgtype    | varchar(255) | NO   |     | NULL    |       |
;| imgyear    | int(11)      | NO   |     | NULL    |       |
;| imgday     | int(11)      | NO   |     | NULL    |       |
;| reflfile   | varchar(255) | NO   |     | NULL    |       |
;| tcfile     | varchar(255) | NO   |     | NULL    |       |
;| cloudfile  | varchar(255) | YES  |     | NULL    |       |
;+------------+--------------+------+-----+---------+-------+
;    
   
   baseout = {project_id:projectid, tsa:tsa, imgtype:'', imgyear:0, imgday:0, reflfile:'', tcfile:'', cloudfile:''}
   image_list = replicate(baseout, n_images)
   for i =0, n_images-1 do begin
      image_list[i].imgtype = imageinfo[i].platform
      image_list[i].imgyear = imageinfo[i].imgyear
      image_list[i].imgday = imageinfo[i].julday
      image_list[i].reflfile = imageinfo[i].reflfile
      image_list[i].tcfile = imageinfo[i].tcfile
      image_list[i].cloudfile = imageinfo[i].cloudfile
   end
   
   ;now write things out
   
   basefile = file_basename(this_tsa_extracted_patchinfo_csv)
   
   outpatchfile = outputdir+ stringswap(basefile, '.csv', $
          strcompress('_proj'+string(projectid)+'.csv', /rem) )
          
   export_structure_to_file,  samples, outpatchfile
   
    basefile2 = file_basename(this_tsa_imagelist_csv)
   
   outimagelistfile = outputdir+stringswap(basefile2, '.csv', $
          strcompress('_proj'+string(projectid)+'.csv', /rem) )
   
   export_structure_to_file, image_list, outimagelistfile
   
   ;now generate the command to run to do the python extraction
   ;  the tsa should be of format 45029, but for all else we need it to be 4529, so use the long version for the command even though
;	we have used the short version above within the .csv files. 
 
   command = strcompress('python extract_chip_rek.py '+string(tsa10000s)+' '+outpatchfile+' '+outimagelistfile+' '+outputdir+' '+strcompress(string(projectid),/rem))
    
    
    return, command
    end
    
        
        
            
    
